---
alwaysApply: true
---

# Next.js 프로젝트 아키텍처 가이드

다음 아키텍처 패턴을 따라 Next.js 프로젝트를 구성하세요.

## 1. API 관리 방식

### 1.1 Axios 인스턴스 생성 및 인터셉터 설정

**파일 위치**: `components/shared/lib/axiosInstance.ts`

```typescript
import axios from "axios";

// 메인 axios 인스턴스 생성
const axiosInstance = axios.create({
   baseURL: process.env.NEXT_PUBLIC_API_BASE_URL,
});

// 토큰 재발행 상태 관리
let isRefreshing = false;
let failedQueue: { resolve: (value: unknown) => void; reject: (reason?: any) => void }[] = [];

// 대기 중인 요청 처리 함수
const processQueue = (error: any, token: string | null = null) => {
   failedQueue.forEach((prom) => {
      if (error) {
         prom.reject(error);
      } else {
         prom.resolve(token);
      }
   });
   failedQueue = [];
};

// 요청 인터셉터 - 모든 요청에 토큰 자동 추가
axiosInstance.interceptors.request.use(
   (config) => {
      if (typeof window !== "undefined") {
         const token = localStorage.getItem("accessToken");
         if (token) {
            config.headers["Authorization"] = `Bearer ${token}`;
         }
      }
      return config;
   },
   (error) => Promise.reject(error)
);

// 응답 인터셉터 - 401 에러 시 토큰 자동 갱신
axiosInstance.interceptors.response.use(
   (response) => response,
   async (error) => {
      const originalRequest = error.config;

      // 401 에러이고 재시도하지 않은 경우
      if (error.response?.status === 401 && !originalRequest._retry) {
         if (isRefreshing) {
            // 이미 갱신 중이면 대기열에 추가
            return new Promise((resolve, reject) => {
               failedQueue.push({ resolve, reject });
            })
               .then((token) => {
                  if (token) {
                     originalRequest.headers["Authorization"] = `Bearer ${token}`;
                  }
                  return axiosInstance(originalRequest);
               })
               .catch((err) => Promise.reject(err));
         }

         originalRequest._retry = true;
         isRefreshing = true;

         try {
            const refreshToken = localStorage.getItem("refreshToken");
            if (!refreshToken) {
               localStorage.removeItem("accessToken");
               processQueue(new Error("No refresh token available"));
               return Promise.reject(error);
            }

            // 토큰 재발행 요청
            const response = await axiosInstance.post("/auth/token", {
               refreshToken,
            });

            if (response.data?.accessToken) {
               const newAccessToken = response.data.accessToken;
               localStorage.setItem("accessToken", newAccessToken);

               if (response.data.refreshToken) {
                  localStorage.setItem("refreshToken", response.data.refreshToken);
               }

               originalRequest.headers["Authorization"] = `Bearer ${newAccessToken}`;
               processQueue(null, newAccessToken);
               return axiosInstance(originalRequest);
            }
         } catch (refreshError) {
            localStorage.removeItem("accessToken");
            localStorage.removeItem("refreshToken");
            processQueue(refreshError);
            return Promise.reject(refreshError);
         } finally {
            isRefreshing = false;
         }
      }

      return Promise.reject(error);
   }
);

export default axiosInstance;
```

### 1.2 커스텀 API 클라이언트 훅

**파일 위치**: `components/shared/hooks/useApiClient.ts`

```typescript
import axios, { AxiosInstance } from "axios";
import { useAuth } from "@/components/shared/hooks/useAuth";
import { useRouter } from "next/navigation";

const API_BASE_URL = process.env.NEXT_PUBLIC_API_BASE_URL;

// 토큰 관리 유틸리티
const TokenManager = {
   getAccessToken: (): string | null => {
      if (typeof window === "undefined") return null;
      try {
         return localStorage.getItem("accessToken");
      } catch (error) {
         return null;
      }
   },
   setAccessToken: (token: string): void => {
      if (typeof window === "undefined") return;
      try {
         localStorage.setItem("accessToken", token);
      } catch (error) {}
   },
   removeAccessToken: (): void => {
      if (typeof window === "undefined") return;
      try {
         localStorage.removeItem("accessToken");
      } catch (error) {}
   },
};

// API 클라이언트 생성 함수
const createApiClient = (): AxiosInstance => {
   const apiClient = axios.create({
      baseURL: API_BASE_URL,
      timeout: 10000,
      headers: {
         "Content-Type": "application/json",
      },
   });

   // 요청 인터셉터
   apiClient.interceptors.request.use(
      (config) => {
         const token = TokenManager.getAccessToken();
         if (token) {
            config.headers.authorization = `Bearer ${token}`;
         }
         return config;
      },
      (error) => Promise.reject(error)
   );

   return apiClient;
};

// 커스텀 훅
export const useApiClient = () => {
   const { logout, refreshUserInfo } = useAuth();
   const router = useRouter();
   const apiClient = createApiClient();

   // 401 에러 처리 인터셉터
   apiClient.interceptors.response.use(
      (response) => response,
      async (error) => {
         if (error.response?.status === 401) {
            try {
               await refreshUserInfo();
               const originalRequest = error.config;
               const newToken = TokenManager.getAccessToken();

               if (newToken && originalRequest && !originalRequest._retry) {
                  originalRequest._retry = true;
                  originalRequest.headers.authorization = `Bearer ${newToken}`;
                  return apiClient.request(originalRequest);
               } else {
                  await logout();
                  router.push("/auth/signin");
               }
            } catch (refreshError) {
               await logout();
               router.push("/auth/signin");
            }
         }
         return Promise.reject(error);
      }
   );

   return apiClient;
};

// 단순 API 클라이언트 (훅 없이 사용)
export const apiClient = createApiClient();
```

### 1.3 사용 예시

```typescript
// 컴포넌트에서 사용
"use client";

import { useApiClient } from "@/components/shared/hooks/useApiClient";
import { useEffect, useState } from "react";

export default function UserList() {
   const apiClient = useApiClient();
   const [users, setUsers] = useState([]);

   useEffect(() => {
      const fetchUsers = async () => {
         try {
            const response = await apiClient.get("/v1/users");
            setUsers(response.data);
         } catch (error) {
            console.error("Failed to fetch users:", error);
         }
      };
      fetchUsers();
   }, []);

   return <div>{/* ... */}</div>;
}
```

## 2. 인증 및 리프레시 토큰 관리

### 2.1 AuthContext 생성

**파일 위치**: `components/shared/context/AuthContext.tsx`

```typescript
"use client";

import React, { createContext, useReducer, useEffect, useCallback } from "react";

// 타입 정의
interface UserInfo {
   id: string;
   name: string;
   email: string;
   permissions?: any;
   // ... 기타 사용자 정보
}

interface AuthState {
   isAuthenticated: boolean;
   user: UserInfo | null;
   loading: boolean;
   error: string;
}

interface AuthContextProps {
   state: AuthState;
   login: (email: string, password: string) => Promise<void>;
   loginWithId: (loginId: string, password: string) => Promise<void>;
   logout: () => Promise<void>;
   refreshUserInfo: () => Promise<void>;
   refreshAccessToken: () => Promise<boolean>;
}

// 액션 타입
type AuthAction =
   | { type: "SET_LOADING"; payload: boolean }
   | { type: "LOGIN_SUCCESS"; payload: UserInfo }
   | { type: "LOGOUT" }
   | { type: "SET_USER"; payload: UserInfo | null }
   | { type: "SET_ERROR"; payload: string }
   | { type: "CLEAR_ERROR" };

// 초기 상태
const initialState: AuthState = {
   isAuthenticated: false,
   user: null,
   loading: true,
   error: "",
};

// 리듀서
const authReducer = (state: AuthState, action: AuthAction): AuthState => {
   switch (action.type) {
      case "SET_LOADING":
         return { ...state, loading: action.payload };
      case "LOGIN_SUCCESS":
         return {
            ...state,
            isAuthenticated: true,
            user: action.payload,
            loading: false,
            error: "",
         };
      case "LOGOUT":
         return {
            ...state,
            isAuthenticated: false,
            user: null,
            loading: false,
            error: "",
         };
      case "SET_USER":
         return {
            ...state,
            user: action.payload,
            isAuthenticated: !!action.payload,
            loading: false,
            error: "",
         };
      case "SET_ERROR":
         return {
            ...state,
            error: action.payload,
            loading: false,
         };
      case "CLEAR_ERROR":
         return { ...state, error: "" };
      default:
         return state;
   }
};

// 컨텍스트 생성
export const AuthContext = createContext<AuthContextProps | undefined>(undefined);

const API_BASE_URL = process.env.NEXT_PUBLIC_API_BASE_URL;

// 토큰 관리 유틸리티
const TokenManager = {
   // 액세스 토큰 (localStorage)
   getAccessToken: (): string | null => {
      if (typeof window === "undefined") return null;
      return localStorage.getItem("accessToken");
   },
   setAccessToken: (token: string): void => {
      if (typeof window === "undefined") return;
      localStorage.setItem("accessToken", token);
   },
   removeAccessToken: (): void => {
      if (typeof window === "undefined") return;
      localStorage.removeItem("accessToken");
   },

   // 리프레시 토큰 (Cookie)
   getRefreshToken: (): string | null => {
      if (typeof window === "undefined") return null;
      const cookies = document.cookie.split(";");
      const refreshCookie = cookies.find((cookie) => cookie.trim().startsWith("refreshToken="));
      return refreshCookie ? refreshCookie.split("=")[1] : null;
   },
   setRefreshToken: (token: string, days: number = 7): void => {
      if (typeof window === "undefined") return;
      const expires = new Date();
      expires.setTime(expires.getTime() + days * 24 * 60 * 60 * 1000);
      document.cookie = `refreshToken=${token}; expires=${expires.toUTCString()}; path=/; secure; samesite=strict`;
   },
   removeRefreshToken: (): void => {
      if (typeof window === "undefined") return;
      document.cookie = "refreshToken=; expires=Thu, 01 Jan 1970 00:00:00 UTC; path=/;";
   },
};

// API 호출 함수들
const AuthAPI = {
   login: async (email: string, password: string) => {
      const response = await fetch(`${API_BASE_URL}/auth/login`, {
         method: "POST",
         headers: { "Content-Type": "application/json" },
         body: JSON.stringify({ email, password }),
      });
      if (!response.ok) throw new Error("로그인에 실패했습니다.");
      return response.json();
   },

   loginWithId: async (loginId: string, password: string) => {
      const response = await fetch(`${API_BASE_URL}/auth/login-id`, {
         method: "POST",
         headers: { "Content-Type": "application/json" },
         body: JSON.stringify({ loginId, password }),
      });
      if (!response.ok) throw new Error("로그인에 실패했습니다.");
      return response.json();
   },

   refresh: async (refreshToken: string) => {
      const response = await fetch(`${API_BASE_URL}/auth/refresh`, {
         method: "POST",
         headers: { "Content-Type": "application/json" },
         body: JSON.stringify({ refreshToken }),
      });
      if (!response.ok) throw new Error("토큰 갱신에 실패했습니다.");
      return response.json();
   },

   validate: async (accessToken: string) => {
      const response = await fetch(`${API_BASE_URL}/auth/validate`, {
         method: "POST",
         headers: {
            "Content-Type": "application/json",
            authorization: `Bearer ${accessToken}`,
         },
      });
      return response.ok;
   },

   logout: async (refreshToken: string) => {
      const response = await fetch(`${API_BASE_URL}/auth/logout`, {
         method: "POST",
         headers: { "Content-Type": "application/json" },
         body: JSON.stringify({ refreshToken }),
      });
      if (!response.ok) throw new Error("로그아웃에 실패했습니다.");
      return response.json();
   },

   getProfile: async (accessToken: string) => {
      const response = await fetch(`${API_BASE_URL}/auth/profile`, {
         method: "GET",
         headers: { authorization: `Bearer ${accessToken}` },
      });
      if (!response.ok) {
         throw new Error(`프로필 조회에 실패했습니다. Status: ${response.status}`);
      }
      return response.json();
   },
};

// AuthProvider 컴포넌트
export const AuthProvider: React.FC<{ children: React.ReactNode }> = ({ children }) => {
   const [state, dispatch] = useReducer(authReducer, initialState);

   // 토큰 자동 갱신
   const refreshAccessToken = useCallback(async (): Promise<boolean> => {
      try {
         const refreshToken = TokenManager.getRefreshToken();
         if (!refreshToken) return false;

         const response = await AuthAPI.refresh(refreshToken);
         if (response.accessToken) {
            TokenManager.setAccessToken(response.accessToken);
            if (response.refreshToken) {
               TokenManager.setRefreshToken(response.refreshToken);
            }
            return true;
         }
         return false;
      } catch (error) {
         return false;
      }
   }, []);

   // 사용자 정보 새로고침
   const refreshUserInfo = useCallback(async (): Promise<void> => {
      try {
         let accessToken = TokenManager.getAccessToken();
         if (!accessToken) {
            dispatch({ type: "LOGOUT" });
            return;
         }

         // 토큰 유효성 검사
         const isValid = await AuthAPI.validate(accessToken);
         if (!isValid) {
            const refreshed = await refreshAccessToken();
            if (!refreshed) {
               dispatch({ type: "LOGOUT" });
               return;
            }
            accessToken = TokenManager.getAccessToken();
         }

         // 프로필 정보 가져오기
         if (accessToken) {
            const userInfo = await AuthAPI.getProfile(accessToken);
            dispatch({ type: "SET_USER", payload: userInfo });
         }
      } catch (error) {
         dispatch({ type: "LOGOUT" });
      }
   }, [refreshAccessToken]);

   // 로그인
   const login = useCallback(
      async (email: string, password: string) => {
         try {
            dispatch({ type: "SET_LOADING", payload: true });
            const response = await AuthAPI.login(email, password);

            if (response.accessToken && response.refreshToken) {
               TokenManager.setAccessToken(response.accessToken);
               TokenManager.setRefreshToken(response.refreshToken);
               await refreshUserInfo();
            } else {
               throw new Error("토큰을 받지 못했습니다.");
            }
         } catch (error: any) {
            dispatch({ type: "SET_ERROR", payload: error.message });
            throw error;
         }
      },
      [refreshUserInfo]
   );

   // 로그아웃
   const logout = useCallback(async () => {
      try {
         const refreshToken = TokenManager.getRefreshToken();
         if (refreshToken) {
            await AuthAPI.logout(refreshToken);
         }
      } catch (error) {
         console.error("Logout error:", error);
      } finally {
         TokenManager.removeAccessToken();
         TokenManager.removeRefreshToken();
         dispatch({ type: "LOGOUT" });
      }
   }, []);

   // 초기 로드 시 사용자 정보 확인
   useEffect(() => {
      const initAuth = async () => {
         const accessToken = TokenManager.getAccessToken();
         if (accessToken) {
            await refreshUserInfo();
         } else {
            dispatch({ type: "SET_LOADING", payload: false });
         }
      };
      initAuth();
   }, [refreshUserInfo]);

   // 주기적 토큰 갱신 (15분마다)
   useEffect(() => {
      const interval = setInterval(() => {
         if (state.isAuthenticated) {
            refreshAccessToken();
         }
      }, 15 * 60 * 1000); // 15분

      return () => clearInterval(interval);
   }, [state.isAuthenticated, refreshAccessToken]);

   const value: AuthContextProps = {
      state,
      login,
      loginWithId: async (loginId: string, password: string) => {
         try {
            dispatch({ type: "SET_LOADING", payload: true });
            const response = await AuthAPI.loginWithId(loginId, password);
            if (response.accessToken && response.refreshToken) {
               TokenManager.setAccessToken(response.accessToken);
               TokenManager.setRefreshToken(response.refreshToken);
               await refreshUserInfo();
            } else {
               throw new Error("토큰을 받지 못했습니다.");
            }
         } catch (error: any) {
            dispatch({ type: "SET_ERROR", payload: error.message });
            throw error;
         }
      },
      logout,
      refreshUserInfo,
      refreshAccessToken,
   };

   return <AuthContext.Provider value={value}>{children}</AuthContext.Provider>;
};
```

### 2.2 useAuth 훅

**파일 위치**: `components/shared/hooks/useAuth.ts`

```typescript
import { useContext } from "react";
import { AuthContext } from "../context/AuthContext";

export const useAuth = () => {
   const context = useContext(AuthContext);
   if (context === undefined) {
      throw new Error("useAuth must be used within an AuthProvider");
   }
   return context;
};
```

### 2.3 Provider 설정

**파일 위치**: `app/layout.tsx` 또는 `components/shared/providers/ClientProviders.tsx`

```typescript
import { AuthProvider } from "@/components/shared/context/AuthContext";

export default function RootLayout({ children }: { children: React.ReactNode }) {
   return (
      <html>
         <body>
            <AuthProvider>{children}</AuthProvider>
         </body>
      </html>
   );
}
```

## 3. 컴포넌트 관리 방식

### 3.1 프로젝트 구조

```
/components
  /features              # 기능별 컴포넌트 (Feature 기반)
    /user-list
      /ui                 # UI 컴포넌트
      /hooks              # 커스텀 훅
      /types              # 타입 정의
      /constants          # 상수
      /utils              # 유틸리티 함수
      index.tsx           # 메인 컴포넌트
    /dashboard
      /ui
      /hooks
      index.tsx
  /layouts                # 레이아웃 컴포넌트
    /header
    /sidebar
    /footer
  /shared                 # 공유 컴포넌트 및 유틸리티
    /context              # React Context
    /hooks                # 커스텀 훅
    /lib                  # 라이브러리 (axios 등)
    /providers            # Provider 컴포넌트
    /stores               # 상태 관리 (Zustand 등)
    /types                # 타입 정의
    /ui                   # 공통 UI 컴포넌트
    /utils                # 유틸리티 함수
```

### 3.2 Feature 컴포넌트 구조 예시

**파일 위치**: `components/features/user-list/index.tsx`

```typescript
"use client";

import { useState, useEffect } from "react";
import { useApiClient } from "@/components/shared/hooks/useApiClient";
import { useAuth } from "@/components/shared/hooks/useAuth";
import UserListTable from "./ui/UserListTable";
import UserListFilters from "./ui/UserListFilters";
import { User } from "./types";

export default function UserList() {
   const apiClient = useApiClient();
   const { state } = useAuth();
   const [users, setUsers] = useState<User[]>([]);
   const [loading, setLoading] = useState(true);

   useEffect(() => {
      const fetchUsers = async () => {
         try {
            const response = await apiClient.get("/v1/users");
            setUsers(response.data);
         } catch (error) {
            console.error("Failed to fetch users:", error);
         } finally {
            setLoading(false);
         }
      };
      fetchUsers();
   }, []);

   if (loading) return <div>Loading...</div>;

   return (
      <div>
         <UserListFilters />
         <UserListTable users={users} />
      </div>
   );
}
```

### 3.3 공유 UI 컴포넌트

**파일 위치**: `components/shared/ui/Button.tsx`

```typescript
import React from "react";

interface ButtonProps {
   variant?: "primary" | "secondary" | "outline";
   size?: "sm" | "md" | "lg";
   children: React.ReactNode;
   onClick?: () => void;
   disabled?: boolean;
   loading?: boolean;
}

export default function Button({
   variant = "primary",
   size = "md",
   children,
   onClick,
   disabled = false,
   loading = false,
}: ButtonProps) {
   const baseClasses = "font-medium rounded-lg transition-colors";
   const variantClasses = {
      primary: "bg-blue-600 text-white hover:bg-blue-700",
      secondary: "bg-gray-600 text-white hover:bg-gray-700",
      outline: "border-2 border-blue-600 text-blue-600 hover:bg-blue-50",
   };
   const sizeClasses = {
      sm: "px-3 py-1.5 text-sm",
      md: "px-4 py-2 text-base",
      lg: "px-6 py-3 text-lg",
   };

   return (
      <button
         className={`${baseClasses} ${variantClasses[variant]} ${sizeClasses[size]}`}
         onClick={onClick}
         disabled={disabled || loading}
      >
         {loading ? "Loading..." : children}
      </button>
   );
}
```

### 3.4 네이밍 규칙

-  **폴더**: kebab-case (예: `user-list`, `onebutton-report-smc-doctor`)
-  **컴포넌트 파일**: PascalCase (예: `UserList.tsx`, `DoctorReportForm.tsx`)
-  **훅 파일**: camelCase with `use` prefix (예: `useAuth.ts`, `useApiClient.ts`)
-  **유틸리티 파일**: camelCase (예: `formatters.ts`, `validators.ts`)
-  **타입 파일**: camelCase (예: `auth.ts`, `types.ts`)

## 4. 주요 패턴 요약

1. **API 관리**: Axios 인스턴스 + 인터셉터로 토큰 자동 추가 및 갱신
2. **인증 관리**: Context API + useReducer로 전역 상태 관리
3. **토큰 저장**: Access Token (localStorage) + Refresh Token (Cookie)
4. **컴포넌트 구조**: Feature 기반 폴더 구조로 도메인별 분리
5. **공유 컴포넌트**: `shared` 폴더에 재사용 가능한 컴포넌트 배치
6. **타입 안정성**: 모든 함수와 컴포넌트에 명시적 타입 지정

## 5. 환경 변수 설정

`.env.local` 파일에 다음 환경 변수를 설정하세요:

```env
NEXT_PUBLIC_API_BASE_URL=https://api.example.com
```

## 6. 의존성 패키지

필요한 패키지 설치:

```bash
npm install axios
# 또는
pnpm add axios
```
